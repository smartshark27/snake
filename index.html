<!DOCTYPE html>
<html>

<head>
    <title>Snakey</title>
    <meta name="viewport" content="user-scalable=no" />
</head>

<body>

    <svg id="canvas"
        style="touch-action: manipulation; position: absolute; left: 0; top: 0; font-family: 'Lucida Console', Monaco, monospace;"
        onload="handleLoad()" onresize="fitToScreen()" onclick="handleMouseClick(event)">
        <rect id="background" x="0" y="0" width="1" height="1" fill="white" />
        <text id="messageTextbox" dominant-baseline="middle" text-anchor="middle" x="50%" y="10%" font-size="16">Tap to
            start</text>
        <circle id="snakeHead" cx="50%" cy="50%" r="20" fill="green" />
        <circle id="snakeBody1" cx="200" cy="200" r="20" fill="orange" />
    </svg>

    <script>
        const FPS = 24;
        const STEP_DISTANCE = 2;

        var gameRunning = false;
        const snakePartIDs = ["snakeHead", "snakeBody1"];
        var snakePartsAreMoving = [false, false];
        const snakePartTargets = [];
        const snakePartTargetIndexes = [0, 0];

        function handleLoad() {
            fitToScreen();
            const snakeHead = document.getElementById('snakeHead');
            snakeHead.setAttribute('cx', window.innerWidth / 2);
            snakeHead.setAttribute('cy', window.innerHeight / 2);
        }

        function fitToScreen() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            const canvas = document.getElementById('canvas');
            canvas.setAttribute('width', width);
            canvas.setAttribute('height', height);

            const background = document.getElementById('background');
            background.setAttribute('width', width);
            background.setAttribute('height', height);
        }

        function handleMouseClick(event) {
            removeMessage();
            snakePartTargets.push({
                x: event.clientX,
                y: event.clientY,
            });
            setAllSnakesToMove();
            if (!gameRunning) {
                startGame();
            }
        }

        function removeMessage() {
            messageTextbox = document.getElementById("messageTextbox");
            messageTextbox.textContent = "";
        }

        function setAllSnakesToMove() {
            snakePartsAreMoving = snakePartsAreMoving.map(isMoving => true);
        }

        async function startGame() {
            gameRunning = true;
            while (gameRunning) {
                await sleep(Math.floor(1000 / FPS));
                moveSnake();
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function moveSnake() {
            snakeStopped = false;
            for (var i = 0; i < snakePartIDs.length; i++) {
                if (snakeStopped) {
                    snakePartsAreMoving[i] = false;
                    continue;
                }
                if (hasReachedTarget(i)) {
                    if (!hasNextTarget(i)) {
                        snakeStopped = true;
                        snakePartsAreMoving[i] = false;
                        continue;
                    }
                    updateTarget(i);
                }
                movePart(i);
            }
        }

        function hasReachedTarget(snakePartIndex) {
            const targetIndex = snakePartTargetIndexes[snakePartIndex];
            if (targetIndex < 0) return true;
            const target = snakePartTargets[targetIndex];

            const partID = snakePartIDs[snakePartIndex];
            const part = document.getElementById(partID);
            const [partX, partY] = getPosition(part);

            return target.x >= partX - STEP_DISTANCE / 2 &&
                target.x <= partX + STEP_DISTANCE / 2 &&
                target.y >= partY - STEP_DISTANCE / 2 &&
                target.y <= partY + STEP_DISTANCE / 2;
        }

        function getPosition(object) {
            const x = Number(object.getAttribute('cx'));
            const y = Number(object.getAttribute('cy'));
            return [x, y];
        }

        function hasNextTarget(snakePartIndex) {
            return snakePartTargetIndexes[snakePartIndex] + 1 < snakePartTargets.length;
        }

        function updateTarget(snakePartIndex) {
            snakePartTargetIndexes[snakePartIndex]++;
        }

        function movePart(snakePartIndex) {
            const id = snakePartIDs[snakePartIndex];
            const part = document.getElementById(id);
            const [x, y] = getPosition(part);

            const targetIndex = snakePartTargetIndexes[snakePartIndex];
            const target = snakePartTargets[targetIndex];

            const [velocityX, velocityY] = calculateVelocity(x, y, target.x, target.y);
            const newX = x + velocityX;
            const newY = y + velocityY;
            part.setAttribute('cx', newX);
            part.setAttribute('cy', newY);
        }

        function calculateVelocity(x, y, targetX, targetY) {
            const displacementX = x - targetX;
            const displacementY = y - targetY;
            const angle = Math.atan(displacementY / displacementX);
            const speedX = Math.cos(angle) * STEP_DISTANCE;
            const speedY = Math.sin(angle) * STEP_DISTANCE;
            const velocityX = (targetX >= x) ? speedX : -speedX
            const velocityY = (targetX >= x) ? speedY : -speedY
            return [velocityX, velocityY];
        }
    </script>

</body>

</html>