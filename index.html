<!DOCTYPE html>
<html>
  <head>
    <title>Snakey</title>
    <meta name="viewport" content="user-scalable=no" />
  </head>

  <body>
    <svg
      id="canvas"
      style="touch-action: manipulation; position: absolute; left: 0; top: 0; font-family: 'Lucida Console', Monaco, monospace;"
      onload="handleLoad()" onclick="handleMouseClick(event)"
    >
      <rect
        id="background"
        x="0"
        y="0"
        width="1"
        height="1"
        fill="white"
      ></rect>
      <circle
        id="candy"
        r="20"
        fill="red"
        display="none"
      />
    </svg>

    <script>
      const FPS = 60;
      const STEP_DISTANCE = 3;
      const PART_RADIUS = 40;
      const PART_SEPARATION = 50;
      const HEAD_FILL = "Green";
      const BODY_FILL = "MediumSeaGreen";
      const SNAKE_START_LENGTH = 3;

      var nextPartID = 0;
      const partIDs = [];
      var partIsMoving = [];
      const targets = [];
      const partTargetIndexes = [];
      var gameRunning = false;
      var gameOver = false;
      var growing = false;
      var growAt;

      function handleLoad() {
        fitToScreen();
        spawnSnake();
        showMessage("Touch to start");
      }

      function spawnSnake() {
        const y = window.innerHeight / 2;
        for (var i = 0; i < SNAKE_START_LENGTH; i++) {
          const x =
            window.innerWidth / 2 - i * (2 * PART_RADIUS + PART_SEPARATION);
          spawnPart(x, y, 0);
        }
        const head = getHead();
        const [headX, headY] = getPosition(head);
        addTarget(headX, headY);
      }

      function spawnPart(x, y, targetIndex) {
        const part = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        const id = getNextPartID();

        part.setAttribute("id", id);
        part.setAttribute("cx", x);
        part.setAttribute("cy", y);
        part.setAttribute("r", PART_RADIUS);
        part.setAttribute("fill", (id == "part0") ? HEAD_FILL : BODY_FILL);
        document.getElementById("canvas").appendChild(part);

        partIDs.push(id);
        partIsMoving.push(false);
        partTargetIndexes.push(targetIndex);
        return part;
      }

      function getNextPartID() {
        const id = "part" + nextPartID.toString();
        nextPartID++;
        return id;
      }

      function getHead() {
        return document.getElementById("part0");
      }

      function addTarget(x, y) {
        targets.push({
          x: x,
          y: y
        });
      }

      function fitToScreen() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        const canvas = document.getElementById("canvas");
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);

        const background = document.getElementById("background");
        background.setAttribute("width", width);
        background.setAttribute("height", height);
      }

      function getPosition(object) {
        const x = Number(object.getAttribute("cx"));
        const y = Number(object.getAttribute("cy"));
        return [x, y];
      }

      function handleMouseClick(event) {
        if (gameOver) return;
        removeMessage();
        const head = getHead();
        const [headX, headY] = getPosition(head);
        updateLastTarget(headX, headY);
        addTarget(event.clientX, event.clientY);
        setAllPartsMoving();
        if (!gameRunning) {
          startGame();
        }
      }

      function removeMessage() {
        const messageTextbox = document.getElementById("messageTextbox");
        if (messageTextbox) {
          messageTextbox.remove();
        }
      }

      function updateLastTarget(x, y) {
        targets[targets.length - 1] = {
          x: x,
          y: y
        };
      }

      function setAllPartsMoving() {
        partIsMoving = partIsMoving.map(isMoving => true);
      }

      async function startGame() {
        gameRunning = true;
        moveCandy();
        revealCandy();
        while (gameRunning) {
          await sleep(Math.floor(1000 / FPS));
          moveSnake();
          checkCollision();
          checkGrow();
        }
      }

      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function revealCandy() {
        const candy = document.getElementById("candy");
        candy.setAttribute("display", "initial");
      }

      function moveCandy() {
        const candy = document.getElementById("candy");
        const [x, y] = getRandomPosition();
        candy.setAttribute("display", "initial");
        candy.setAttribute("cx", x);
        candy.setAttribute("cy", y);
      }

      function getRandomPosition() {
        const canvas = document.getElementById("canvas");
        const canvasWidth = canvas.getAttribute("width");
        const canvasHeight = canvas.getAttribute("height");
        const x = generateRandomNumberBetween(0, canvasWidth);
        const y = generateRandomNumberBetween(0, canvasHeight);
        return [x, y];
      }

      function generateRandomNumberBetween(min, max) {
        return Math.floor(Math.random() * max) + min;
      }

      function moveSnake() {
        stopped = false;
        for (var i = 0; i < partIDs.length; i++) {
          if (stopped) {
            stopMoving(i);
            continue;
          }
          if (hasReachedTarget(i)) {
            if (!hasNextTarget(i)) {
              stopped = true;
              stopMoving(i);
              continue;
            }
            updateTarget(i);
          }
          movePart(i);
        }
      }

      function stopMoving(partIndex) {
        partIsMoving[partIndex] = false;
      }

      function hasReachedTarget(partIndex) {
        const targetIndex = partTargetIndexes[partIndex];
        const target = targets[targetIndex];

        const partID = partIDs[partIndex];
        const part = document.getElementById(partID);
        const [x, y] = getPosition(part);

        return (
          target.x >= x - STEP_DISTANCE / 2 &&
          target.x <= x + STEP_DISTANCE / 2 &&
          target.y >= y - STEP_DISTANCE / 2 &&
          target.y <= y + STEP_DISTANCE / 2
        );
      }

      function hasNextTarget(partIndex) {
        return partTargetIndexes[partIndex] + 1 < targets.length;
      }

      function updateTarget(partIndex) {
        partTargetIndexes[partIndex]++;
      }

      function movePart(partIndex) {
        const id = partIDs[partIndex];
        const part = document.getElementById(id);
        const [x, y] = getPosition(part);

        const targetIndex = partTargetIndexes[partIndex];
        const target = targets[targetIndex];

        const [velocityX, velocityY] = calculateVelocity(
          x,
          y,
          target.x,
          target.y
        );
        const newX = x + velocityX;
        const newY = y + velocityY;
        part.setAttribute("cx", newX);
        part.setAttribute("cy", newY);
      }

      function calculateVelocity(x, y, targetX, targetY) {
        const displacementX = x - targetX;
        const displacementY = y - targetY;
        const angle = Math.atan(displacementY / displacementX);
        const speedX = Math.cos(angle) * STEP_DISTANCE;
        const speedY = Math.sin(angle) * STEP_DISTANCE;
        const velocityX = targetX >= x ? speedX : -speedX;
        const velocityY = targetX >= x ? speedY : -speedY;
        return [velocityX, velocityY];
      }

      function checkCollision() {
        checkCollisionWithCandy();
        checkCollisionWithSnake();
      }

      function checkCollisionWithCandy() {
        const head = getHead();
        const candy = document.getElementById("candy");
        const collision = haveCirclesCollided(head, candy);
        if (collision) {
          moveCandy();
          startGrowing();
        }
      }

      function haveCirclesCollided(circleA, circleB) {
        const aX = circleA.getAttribute("cx");
        const aY = circleA.getAttribute("cy");
        const bX = circleB.getAttribute("cx");
        const bY = circleB.getAttribute("cy");
        const distanceBetween = getDistanceBetween(aX, aY, bX, bY);
        const aRadius = Number(circleA.getAttribute("r"));
        const bRadius = Number(circleB.getAttribute("r"));
        return distanceBetween < aRadius + bRadius;
      }

      function getDistanceBetween(aX, aY, bX, bY) {
        const xDiff = Math.abs(aX - bX);
        const yDiff = Math.abs(aY - bY);
        return Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
      }

      function startGrowing() {
        growing = true;
        const tail = getTail();
        const [x, y] = getPosition(tail);
        growAt = {
          x: x,
          y: y
        };
      }

      function checkGrow() {
        if (growing) {
          tryGrow();
        }
      }

      function tryGrow() {
        const tail = getTail();
        const [tailX, tailY] = getPosition(tail);
        const distanceBetween = getDistanceBetween(
          growAt.x,
          growAt.y,
          tailX,
          tailY
        );
        if (distanceBetween >= 2 * PART_RADIUS + PART_SEPARATION) {
          const tailTarget = partTargetIndexes[partIDs.length - 1];
          spawnPart(growAt.x, growAt.y, tailTarget);
          growing = false;
          growAt = null;
        }
      }

      function getTail() {
        const id = partIDs[partIDs.length - 1];
        return document.getElementById(id);
      }

      function checkCollisionWithSnake() {
        if (hasHeadCollidedWithBody()) {
          stopGame();
        }
      }

      function stopGame() {
        gameRunning = false;
        gameOver = true;
        showMessage("Snake has hit itself! Game over. Refresh page to restart");
      }

      function showMessage(message) {
        console.log(message);
        removeMessage();
        const messageTextbox = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "text"
        );
        messageTextbox.setAttribute("id", "messageTextbox");
        messageTextbox.setAttribute("dominant-baseline", "middle");
        messageTextbox.setAttribute("text-anchor", "middle");
        messageTextbox.setAttribute("x", "50%");
        messageTextbox.setAttribute("y", "20%");
        messageTextbox.setAttribute("font-size", "24");
        document.getElementById("canvas").appendChild(messageTextbox);
        messageTextbox.textContent = message;
      }

      function hasHeadCollidedWithBody() {
        var collision = false;
        const head = getHead();
        partIDs.forEach(id => {
          if (collision) return;
          if (id === partIDs[0]) return;
          const part = document.getElementById(id);
          collision = haveCirclesCollided(head, part);
        });
        return collision;
      }
    </script>
  </body>
</html>
