<!DOCTYPE html>
<html>
  <head>
    <title>Snakey</title>
    <meta name="viewport" content="user-scalable=no" />
  </head>

  <body>
    <svg
      id="canvas"
      style="touch-action: manipulation; position: absolute; left: 0; top: 0; font-family: 'Lucida Console', Monaco, monospace;"
      onload="handleLoad()"
    >
      <rect
        id="background"
        x="0"
        y="0"
        width="1"
        height="1"
        fill="white"
        onclick="handleMouseClick(event)"
      ></rect>
      <text
        id="messageTextbox"
        dominant-baseline="middle"
        text-anchor="middle"
        x="50%"
        y="20%"
        font-size="16"
      >
        Tap the screen
      </text>
      <circle
        id="candy"
        cx="-10"
        cy="-10"
        r="20"
        fill="red"
        display="none"
        onclick="handleMouseClick(event)"
      />
    </svg>

    <script>
      const FPS = 60;
      const STEP_DISTANCE = 3;
      const PART_RADIUS = 30;
      const SNAKE_FILL = "green";
      const SNAKE_START_LENGTH = 7;
      const SNAKE_START_POS_X = 50;
      const SNAKE_START_POS_Y = 50;

      var nextPartID = 0;
      const partIDs = [];
      var partIsMoving = [];
      const targets = [];
      const partTargetIndexes = [];
      var started = false;

      function handleLoad() {
        fitToScreen();
        spawnSnake();
      }

      function spawnSnake() {
        for (var i = 0; i < SNAKE_START_LENGTH; i++) {
          const x = SNAKE_START_POS_X + i * 2 * PART_RADIUS;
          spawnPart(x, SNAKE_START_POS_Y);
        }
        const head = getHead();
        const [x, y] = getPosition(head);
        addTarget(x, y);
      }

      function spawnPart(x, y) {
        const part = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        const id = getNextPartID();

        part.setAttribute("id", id);
        part.setAttribute("cx", x);
        part.setAttribute("cy", y);
        part.setAttribute("r", PART_RADIUS);
        part.setAttribute("fill", SNAKE_FILL);
        document.getElementById("canvas").appendChild(part);

        partIDs.push(id);
        partIsMoving.push(false);
        partTargetIndexes.push(0);
      }

      function getNextPartID() {
        const id = "part" + nextPartID.toString();
        nextPartID++;
        return id;
      }

      function getHead() {
        return document.getElementById("part0");
      }

      function addTarget(x, y) {
        targets.push({
          x: x,
          y: y
        });
      }

      function fitToScreen() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        const canvas = document.getElementById("canvas");
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);

        const background = document.getElementById("background");
        background.setAttribute("width", width);
        background.setAttribute("height", height);
      }

      function getPosition(object) {
        const x = Number(object.getAttribute("cx"));
        const y = Number(object.getAttribute("cy"));
        return [x, y];
      }

      function handleMouseClick(event) {
        removeMessage();
        const head = getHead();
        const [headX, headY] = getPosition(head);
        updateLastTarget(headX, headY);
        addTarget(event.clientX, event.clientY);
        setAllPartsMoving();
        if (!started) {
          start();
        }
      }

      function removeMessage() {
        messageTextbox = document.getElementById("messageTextbox");
        messageTextbox.textContent = "";
      }

      function updateLastTarget(x, y) {
        targets[targets.length - 1] = {
          x: x,
          y: y
        };
      }

      function setAllPartsMoving() {
        partIsMoving = partIsMoving.map(isMoving => true);
      }

      async function start() {
        started = true;
        moveCandy();
        revealCandy();
        while (started) {
          await sleep(Math.floor(1000 / FPS));
          moveSnake();
          checkCollision();
        }
      }

      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function revealCandy() {
        const candy = document.getElementById("candy");
        candy.setAttribute("display", "initial");
      }

      function moveCandy() {
        const candy = document.getElementById("candy");
        const [x, y] = getRandomPosition();
        candy.setAttribute("display", "initial");
        candy.setAttribute("cx", x);
        candy.setAttribute("cy", y);
      }

      function getRandomPosition() {
        const canvas = document.getElementById("canvas");
        const canvasWidth = canvas.getAttribute("width");
        const canvasHeight = canvas.getAttribute("height");
        const x = generateRandomNumberBetween(0, canvasWidth);
        const y = generateRandomNumberBetween(0, canvasHeight);
        return [x, y];
      }

      function generateRandomNumberBetween(min, max) {
        return Math.floor(Math.random() * max) + min;
      }

      function moveSnake() {
        stopped = false;
        for (var i = 0; i < partIDs.length; i++) {
          if (stopped) {
            stopMoving(i);
            continue;
          }
          if (hasReachedTarget(i)) {
            if (!hasNextTarget(i)) {
              stopped = true;
              stopMoving(i);
              continue;
            }
            updateTarget(i);
          }
          movePart(i);
        }
      }

      function stopMoving(partIndex) {
        partIsMoving[partIndex] = false;
      }

      function hasReachedTarget(partIndex) {
        const targetIndex = partTargetIndexes[partIndex];
        const target = targets[targetIndex];

        const partID = partIDs[partIndex];
        const part = document.getElementById(partID);
        const [x, y] = getPosition(part);

        return (
          target.x >= x - STEP_DISTANCE / 2 &&
          target.x <= x + STEP_DISTANCE / 2 &&
          target.y >= y - STEP_DISTANCE / 2 &&
          target.y <= y + STEP_DISTANCE / 2
        );
      }

      function hasNextTarget(partIndex) {
        return partTargetIndexes[partIndex] + 1 < targets.length;
      }

      function updateTarget(partIndex) {
        partTargetIndexes[partIndex]++;
      }

      function movePart(partIndex) {
        const id = partIDs[partIndex];
        const part = document.getElementById(id);
        const [x, y] = getPosition(part);

        const targetIndex = partTargetIndexes[partIndex];
        const target = targets[targetIndex];

        const [velocityX, velocityY] = calculateVelocity(
          x,
          y,
          target.x,
          target.y
        );
        const newX = x + velocityX;
        const newY = y + velocityY;
        part.setAttribute("cx", newX);
        part.setAttribute("cy", newY);
      }

      function calculateVelocity(x, y, targetX, targetY) {
        const displacementX = x - targetX;
        const displacementY = y - targetY;
        const angle = Math.atan(displacementY / displacementX);
        const speedX = Math.cos(angle) * STEP_DISTANCE;
        const speedY = Math.sin(angle) * STEP_DISTANCE;
        const velocityX = targetX >= x ? speedX : -speedX;
        const velocityY = targetX >= x ? speedY : -speedY;
        return [velocityX, velocityY];
      }

      function checkCollision() {
        checkCollisionWithCandy();
      }

      function checkCollisionWithCandy() {
        const head = getHead();
        const candy = document.getElementById("candy");
        const distanceBetween = getDistanceBetween(head, candy);
        const headR = Number(head.getAttribute("r"));
        const candyR = Number(head.getAttribute("r"));
        if (distanceBetween < headR + candyR) {
          moveCandy();
        }
      }

      function getDistanceBetween(circleA, circleB) {
        const aX = circleA.getAttribute("cx");
        const aY = circleA.getAttribute("cy");
        const bX = circleB.getAttribute("cx");
        const bY = circleB.getAttribute("cy");

        const xDiff = Math.abs(aX - bX);
        const yDiff = Math.abs(aY - bY);

        return Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
      }
    </script>
  </body>
</html>
